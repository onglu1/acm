#include <iostream>
#include <algorithm>
using namespace std;
const int N = 209;
int solve(int n, int a[], int b[]) {
    int la = 0, ra = n - 1;
    int lb = 0, rb = n - 1;
    // 一直循环到长度小于等于2
    while(ra - la + 1 > 2) {
        int ma = (la + ra) / 2;
        int mb = (lb + rb) / 2;
        // 如果两个数相同，那么说明找到中位数了
        if(a[ma] == b[mb]) return a[ma];
        // 如果两个数不同，那么取大的那个序列的前半，小的那个序列的后半
        if(a[ma] >  b[mb]) {
            // 长度为偶数的时候，取一半会不等长
            // 需要把短的那一段往后延长一位，保证等长
            if((ra - la + 1) % 2 == 0) {
                ra = ma + 1;
            } else {
                ra = ma;
            }
            lb = mb;

        } else {
            la = ma;
            // 长度为偶数的时候，取一半会不等长
            // 需要把短的那一段往后延长一位，保证等长
            if((rb - lb + 1) % 2 == 0) {
                rb = mb + 1;
            } else {
                rb = mb;
            }
        }
    }
    // 如果长度为2
    if(ra - la + 1 == 2) {
        // 特判找到中位数
        if(a[la] < b[lb]) return min(a[ra], b[lb]);
        else return min(a[la], b[rb]);
    }
    // 如果长度为1，中位数是较小的那个数
    return min(a[la], b[lb]);
}
int main(){
    int n, a[N], b[N];
    cin >> n;
    for(int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for(int i = 0; i < n; i++) {
        cin >> b[i];
    }
    cout << solve(n, a, b) << endl;
    return 0;
}
/*
8
1	4	7	11	23	24	30	40
1	2	3	5	23	25	26	27

 * 我们利用分治法解决这个问题
 * 对于两个等长的序列，我们不妨假设第一个序列的中位数l小于第二个序列的中位数r
 * 我们可以证明，两个序列合并后的中位数x满足l <= x <= r
 * 我们可以利用反证法来证明：
 * 假设x < l
 * 那么在第一个序列中，有至少 (n + 1) / 2个元素大于x
 * 在第二个序列中，由于r > l，那么也有至少(n + 1) / 2个元素大于x
 * 两个序列加起来一共有超过n + 1个元素大于x，说明x一定不是中位数
 * 反之同理
 * 我们可以扔掉第一个序列的前半部分好第二个序列的后半部分
 * 那么由于两个序列中中位数所在的位置相同，所以两个序列扔掉的数字个数也是相同的
 * 相当于，我们扔掉了k个比中位数大的数字和k个比中位数小的数字
 * 所以在扔掉之后的新序列中，中位数不会发生变化，所以我们就有了一个算法，每次会将问题规模减小一半
 * T(n) = T(n / 2) = O(log n)
 * 最后我们还需要处理n = 1和n = 2的时候的问题
 * n = 1的时候，显然较小的那个元素是中位数
 * n = 2的时候
 * 先假设a[0] < b[0]
 * 那么min(b[0], a[1])就是答案
 * 因为a[0]是四个元素中最小的元素，抛开这个元素后，剩下3个元素中最小的那个元素就是中位数
 * 那么由于b[1] > b[0]，那么b[1]显然不是中位数，答案就是min(b[0], a[1])
 *
 */