#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N = 2e6 + 1009;
int n, m, a[N];
int ans = 0;
string s;
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    cin >> s;
    // 读入串，转化成01串
    for(int i = 1; i <= n; i++) {
        a[i] = s[i - 1] == 'G';
    }
    cout << endl;
    int i = 1;
    // 先抛弃掉首部的一些00和11
    while(i <= n && a[i] == a[i + 1]) i += 2;
    if(i > n) {
        cout << 0 << endl;
        return 0;
    }
    // 记录上一段的颜色
    int lst = a[i + 1];
    i += 2;
    while(i <= n) {
        // 00和11直接忽略掉
        if(a[i] == a[i + 1]) {
            i += 2;
            continue;
        }
        // 如果新的颜色跟上面整段颜色不同，需要花一次翻转把上面一整段变成新的这个颜色
        if(a[i + 1] != lst) {
            ans++;
            lst = a[i + 1];
        }
        i += 2;
    }
    // 如果最后颜色不是1，那么还需要花一次翻转机会
    ans += lst != 1;
    cout << ans << endl;
    return 0;
}
/*
 * 我们记G = 1, H = 0，方便叙述
 * 我们把所有0和1两个两个组合，显然00和11不会影响最终的种类个数，我们可以直接无视这样的组合
 * 对于01，我们交换之后他们会变成10，对于10同理
 * 我们可以记01为1， 10为0，这样每次翻转操作就变成了：翻转前缀，并且0变成1,1变成0
 * 我们目的是尽可能的把0变成1，这个显然是很容易完成的
 * 我们可以发现，经过上述的压缩叙述操作，数组一定是会变成类似0000111100011110000
 * 就是若干个0和若干个1这样相间的
 * 那么答案就呼之欲出了，我们每次选前缀最长的一个连续相同的字符，把他翻转，直到最后整个串都是1
 * 比如说00110001100
 * 第一次操作之后变成11110001100
 * 第二次操作之后变成00000001100
 * 第三次操作之后变成11111111100
 * 第四次操作之后变成00000000000
 * 由于还不是全1，我们最后还要操作一次，变成11111111111
 * 一共操作五次，这样显然是最优的，因为一个n段的字符串，最少要n - 1次翻转才能全部相同
 * 最后答案是n还是n - 1取决于最后一个字符是0或是1
 *
 *
 */